1. INTRODUCTION TO DB2 / SQL
2. HOW TO COBOL-DB2 PGMS
	1. CREATE A TABLE
	2. DCLGEN COPYBOOK
	3. COBOL-DB2 PGM
	4. PRE-COMPILATION***
	5. EXECUTION
3. COBOL-DB2 PROGRAM
	1. INSERT	 + INSERT ACCEPT + INSERT FILE + INSERET FILE SUBPGM
	2. SELECT  + CURSOR  - 305 -811  -SCROLL , ROWSET
	3. UPDATE	== 1 PGM  , MAIN-SUB WITH UPDATE   , 1 -UPDATE -RESTART LOGIC
4. LOAD & UNLOAD
5. SQLCODE ERROR CODE
6. SQL SELECT QUERY + VIEW _ JOIN - SUB QUERY
=======================================================10-12 SESSION
4. LOAD & UNLOAD:
-------------------------------------

LOAD = UNLOAD =--> UTUL -> DSNUTILB

	DEV ->   TESTING PURPOSE -> 

		IF THE DATA IS IN FILE -> FTP/ICEING -.> PROD FILE (PROD-TSO ) --> TEST FILE(TEST - TSO)
		IF THE DATA IN IN TABLE -->  1. UNLOAD THE DATA FROM TABLE -> FILE
						2. FTP THE FILE FROM PROD-TSO  TO  TEST-TSO
					     3. LOAD ->  FILE => TEST TABLE

	MAINTAIN -->	 REQ FROM THE DEV/OTHER TEAM USER -> CONTACTING U TO REFER THE TEST / SYSTEM TABLE
			= PROD - UNLOAD
			= TEST - LOAD

	SUPT:	--> ALREADY U WIL BE HAVING JOBS -- UNLOAD , LOAD

HOW TO DO LOAD & UNLOAD:

UNLOAD  ->   TABLE  TO  A FILE
LOAD	->  FILE	TO A TABLE

	2 FILE 			1. REC FILE	2. PUNCH FILE
				  DATA		    MAPPING - COL = DATA POS + LOAD COMMAND
	1 TABLE

UNLOAD ->  SELECT QUERY -> NO LOCK IS REQUIRED

	2 WAYS	->	 DSNUTILB --> EXEC PGM=DSNUTILB	==> UNLOAD COMMAND -TABLE - COL U NEED
			 	 DSNTIAUL --> EXEC PGM=IKJEFT01 --> SELECT QUERY -> ABLE COL. ROW ALSO

//SYSTSIN  DD  *                                     
 DSN SYSTEM(DB8G)                                    
 RUN  PROGRAM(DSNTIAUL) PLAN(DSNTIB81) PARMS('SQL') -
      LIB('DSN810.RUNLIB.LOAD')                      
/*                                 

LOAD ->     KEEP THE DATA FROM FILE - TABLE

	2 TYPE		1. LOAD RESUME	----> APPEND - ADD MORE NED RECORD ( ONLY INSERT QUERY)
			2. LOAD REPLACE   --> REMOVE AND INSERT   (INSERT + UPDATE + DELETE)


		TABLE -> 3 YEARS DATA

	LOAD FILE:   1. CONTAINS -> ONLY TODAY DATA			- LOAD RESUME
		     2. CONTAINS -> LAST 3 YEAR + TODAY DATA		- LOAD REPLACE

	AS WE ARE INVOLVING THE INSERT -ADD BULK DATA ->  WE NEED -PERFORM THIS LOAD..

		LOCK - LOAD - RELESE

LOCK IN DB2:	1. ROW LEVEL LOCK		== COBOL-DB2 PGM *UPDATE
				-> BIND PARAMETER -> ISOLATION LEVEL
													TABLE - 1000 ROWS
					RR	-- REPEATABLE READ	- QUERY -. SCAN THE ROW FOR MATCHING--> 100 	- LOCKED
					RS	-- READ STABILITY	- QUERY -> SCAN - RESULT SET 		10	- LOCKED
					CS	-- CURSOR STABILITY	- QUERY -> SCAN - RESULT SET -- FETCH   1	- LOCKED
					UR	-- UN-COMMITED READ	- QUERY - SCAN  - RESULT -FETCH ->      0	- NO LOCK (SELECT)

			PROJECT - PERFOMQANCE - DEFAULT --> WE USE = CS***

		2. TABLE-SPACE LEVEL LOCK
			RW - UT
			     UT - UT,COPY
				  UT-COPY  -- UT
					      UT -- RW

			LOAD JOB 4 STEPS
				1. LOCK THE TABLESPACE   (ANY TABLESPACE - ACCESSABLE -> STATUS => RW MODE (READ-WRITE MODE))
				     STOP THE DATABASE-TABLESPACE
				     START -THE DATABASE-TABLESPACE -> ACCESS(UT)	- UT - UTIL LOCK
				  RW- UT

				2. LOAD => REPLACE / RESUME ==> DATA FROM FILE - TABLE
					
				  UT - UT,COPY   (COPY PENDING STATUS)

				3. REPAIR +RUNSTATS  --> UPDATE THE DB2 CATALOG TABLE / INDEX AFTERR THE LOAD

				  UT,COPY -- UT

				4. UNLOCK THE TABLE SPACE
					STOP 
					START -- ACCESS (RW)

				 UT - RW
				

















                















==================================================================================
3. UPDATE:

1. MAIN _ SUB
2. RESTART

DB2 RESTART LOGIC

>> IN A UPDATE PROGRAM - WHERE WE HAVE A COMMIT TO SAVE THE CHANGE -> GOT FAILED AFTER UPDATEING SOME RECORD.
NEXT =RERUN => SHOULD UPDATE ONLY THE RECORD WHICH ARE NOT UPDATED IN 1ST RUN..

	RESTART LOGIC
		PGM
			1. FIRST TIME --> UPDATE FROM 1ST ROW OF THE CURSOR  (NORMAL PROCESS)
			2. RESTART/LATER ->  UPDATE SHOULD START AFTER FETCHIN THE LAST COMMITED ROW

NORMAL PROCESS -->   OPEN +  FETCH +  UPDATE --> COUNT=2 =COMMIT -> WRITE THE RECORD TO A FILE (LAST COMMITED RECORD)< RESTART FILE
		== LET SAY -> 4 RECORC COMMIT -> 5TH RECORD - ABEND
RESTART PROESS  ->  1. GET THE LAST COMMITED ROW  --> READ THE FILE TILL END.. GET THE LAST COMMIT RECORD KEY - HOLD IT
		    2. OPEN + FETCH - TILL LAST COMMITED ROW == ONCE REACHED ->  SET THE UPDATE SWITCH = 'Y'
		    3. FROM THE NEXT ROW ---FETCH +  UPDATE --> COUNT=2 =COMMIT -> WRITE THE RECORD TO A FILE (LAST COMMITED RECORD)< RESTART FILE

 






  CLAIM TABLE						- POLICY TABLE
  -MAINPGM		 				  SUBPGM
 ->
1. FETCH CLAIM ROW -> SEND TO SUBPGM				1. AUDIT 	1. POLICY NUMBER 			99
										2. CLAIM AMOUNT < INSURED 		01
										3. CLAIM SUB DT < POLICY EXPIRE		02
								2. REPLY = BACK						00 - VALID

2. TO CHECK THE RTN-CODE OF THE SUBPGM
	IF ITS VALID -> CLAIM-STATUS =UPDATE - APPROVE
		99  - REJECT
		01/02 - PENDING


---------+---------+---------+---------+---------+---------+---------+-
CLAIM_NUMBER  CLAIM_AMOUNT  CLAIM_STATUS  POLCY_NUMBER  CLAIM_SUBMIT_DT
---------+---------+---------+---------+---------+---------+---------+-
C1111               100.00  SUBMIT        P1111         2021-10-07     	VALID --> 	APPROVE
C2222               400.00  SUBMIT        P2222         2021-10-07      INVALID -> CLAIM AMOUNT -> PENDING 
C3333               100.00  SUBMIT        P3333         2021-10-07      INVALID -> CLAIM SUB DT -> REJECT
C4444               100.00  SUBMIT        P4444         2021-10-07     	IVALID  -. POLICY  - REHJECT
DSNE610I NUMBER OF ROWS DISPLAYED IS 4                                 
DSNE616I STATEMENT EXECUTION WAS SUCCESSFUL, SQLCODE IS 100            
---------+---------+---------+---------+---------+---------+---------+-

POLCY_NUMBER  CUST_NAME   INSURED_AMT  POLCY_EXPIRE_DT 
---------+---------+---------+---------+---------+-----
P1111         ANIL KUMAR       300.00  2021-10-30    		  
P2222         ANIL KUMAR       100.00  2021-10-30      
P3333         ANIL KUMAR       100.00  2021-10-01      
DSNE610I NUMBER OF ROWS DISPLAYED IS 3                 





	UPDATE TABLENAME
	SET COL = NEW-VALUE;	== UPDATE THE WHOLE TABLE

	UPDATE TABLENAME
	SET COL = NEW-VALUE
	WHERE CONDITION;	== SELECTIVE ROW UPDATE

BULK UPDATES:   -- WE WILL RUN INTO AN ISSUE 		-904 = RESOURCE UNAVILABLE

	COMMIT OF THE CHANGE ->  	1. TIME LIMIT = ANY QUERY EXCEEDING THE TIME LIMIT OF 	QUERY	-> -904
					2. ROW LIMIT  = WHEN U EXCEED THIS ROWLIMIT			-> -904

	WE NEED TO USE CURSOR + UPDATE  -> CHANGE --> CERTAIN COMMIT --> UR CURSOR WIL BE CLOSED
								-TO KEEP THE CURSOR IN OPEN -<WITH HOLD>





2. SELECT  + CURSOR  - 305


	INSERT -> SQLCODE 000 ,  -803 -DUPLICATE INSERT
	SELECT/FETCH ->  SQLCODE 00  => -811 & -305

	-811 => CUROSR  & REMOVE THE DUPLICATE DATA IN TABLE

-305 -> IN CASE WE DONT CODE THE NULL INDICATOR VARIBALE FOR A COLUMN
==? 
	SOLEVE -	3 STEPS
				1. DEFINE THE NULL IND VARIBALE IN WORKING-STORAGE

					01 WS-NULL-IND		PIC 	S9(04) COMP.

				2. TAG THE VARIBALE WITL THE COLUMN DCL-VARA IN THE QUERY

					EXEC SQL FETCH/SELECT
						:DCL-VAR
						:DCL-VAR:WS-NULL-IND		(NO SPACE , NO COMMAND)

					> IN HERE -305 IS RESOLVED
						SQLCODE=00  ->  COL HAVE DATA -> WS-NULL-IND = 0
									NULL  -> WS-NULL-IND = -1

				3. IF SQLCODE = 00
					IF WS-NULL-IND < 0
						1. ABEND THE PGM -> COL DATA IS REQUIRED FOR PGM LOGIC
						2.   A. MOVE SPACE/ZERO TO DCL-VAR
						     B. SKIP THE ROW PROCESS- SEND TO IT ERROR FILE


NOW I WANT TO GET THE DATA FROM THE TABLE -->  SELECT QUERY

	SELECT * FROM SCHEMA.TABLENAME;
	SELECT COL1,COL2 FROM SCHEMA.TABLENAME;
	SELECT COL1,COL2 FROM SCHEMA.TABLENAME WHERE CONDITION;

PGM

	SELECT COL1,COL2 FROM SCHEMA.TABLENAME WHERE CONDITION;		= RESULT SHOULD BE ONLY 1 RECORD

COBOL - IS TO WORK ON 1 SINGLE ROW ALWAYTS
SELECT -> FETCH 1 ROW OR MULTIPLE

	SELECT -> QUERY => MULTIPLE ROWS - RESULT SET -> COBOL PGM (1SET OF VARIBALE -FOR 1 ROWS) -=> SQLCODE = -811

	SQLCODE = -811 -> WHENEVER OUR SELECT QUERY IN PGM , TRYING TO RETIIVE MORE THAN 1 ROW.

		SOLUTION: 
DEV : AND UR REQUIEMENT ITSELF IS STATIING TO GET MULTIPLE ROWS -> SELECT + CURSOR

>>	TO GET ALL CLAIM DATA FOR THE DAY > VALIDATE EACH ROW WITH THE POLICY TABLE

		CLAIM TABLE	: SELECT+CURSOR
		POLICY TABLE	: SELECT+WHERE

	SINGLE -> SELECT + WHERE
	MULTIPLE --> SELECT + CURSOR

>>  I WOULD LIKE TO GET ALL CLAIM NUMBER FOR A GIVEN POLICY NUMBER..

	PGM1 -> FILE (POLICY NUMBER) --> CLAIM TABLE 
			CLAIM-TABLE ??		SELECT + CURSOR + WHERE
		

	PGM2 -> TABLE (POLICY NUMBER) --> CLAIM TABLE

			POLICY-TABLE	-->  SELECT + CURSOR
			CLAIM-TABLE	-->  SELECT + CURSOR

>> FOR A GIVEN POLICY NUMBER I WANT TO GET THE LAST/LATEST CLAIM NUMBER ONLY
	POLICY  -> MULTUPLE CLAIM
		  -> SELECT CLAIM=DATA FROM CLAIM TABLE
				WHERE POILCY_NUMBER = GIVEN-INPUT-NUMBER 
				ORDER BY CLAIM_SUB_DT DESC
				FETCH FIRST ROW ONLY

	POLICY_NUMBER <<			CLAIM_NUMBER
	P111111,ANIL,1000			C111111, 100, P11111
						C222222, 100, P11111


1. GET THE DATA FROM THE TABLE:

	1. SELECT + WHERE --> CONDITION -> RESULT SHOULD BE 1 ROWS ONLY
	2. SELECT + CURSOR ->   RESULT CAN BE 1 OR MORE ROWS 
 
	EXEC SQL  SELECT COL1,COL2..
			INTO :DCL-VAR,:DCL-VAR...
		  FROM TABLENAME
		WHERE CONDTITION (REQUIRED)			1. IF ITS ON A UNIQUE/PK COLUMN -> WE WIL GET ONLY 1 ROWS ALWAYS
								2. IF ITS NOA A UNIQUE /PK COLUMN -> WE MAY HAVE DUPLICATE
									SQLCODE = -811 (PRODUCTION CASE)
		FETCH FIRST 1 ROW ONLY		= TO GET ONLY 1 ROW ,EVEN IN CASE OF DUPLICATE..
	END-EXEC.



2. CURSOR -> 	4 STAGES

		1. DECLARE THE CURSOR
		2. OPEN THE CURSOR
		3. FETCH THE ROWS
		4. CLOSE 

1. DECLARE THE CURSOR
			IN HERE WE NEED TO PROVIDE

		1. CURSOR NAME
		2. TYPES OF CURSOR
					1. SCROLL  & NON-SCROLL(DEFAULT)  => 
						SCROLL -> USED TO GET ANY ROW IN ORDER FROM THE CURSOR RESULT TABLE
						NON-SCROLL -> USED TO GET ROWS 1 BY 1 FROM TOP - BOTTOM IN SEQ 

					2. DYNAMIC  & STATIC (DEFAULT)
						DURING CURSOR ROW UPDATES***
							STATIC   ->  CHANGE WIL BE ON RESULT SET --> COMMIT -> UPDATE THE TABLE - SAVE THEM
							DYNAMIC --> CHANGE WIL BE ON THE TABLE   --> COMMIT -> CHANGE SAVED 

					3. WITH HOLD  & WITHOUT HOLD (DEFAULT) -> LATER  (WHILE DATA UPDATE)


		3. SELECT QUERY + COLUMN + TABLE + WHERE (IF ANY)
		4. FOR FETCH ONLY / FOR UPDATE OF 

	EXEC SQL  DECLARE C-NAME CURSOR
			FOR
			SELECT COL1 ,COL2 ... 
			FROM TABLENAME
			WHERE CONDITION
		 FOR FETCH ONLY / FOR UPDATE OF
	END-EXEC.


	2. OPEN THE CURSOR -->  	EXEC SQL  OPEN C-NAME END-EXEC.
		
		>> THE SELECT QUERY -> WIL BE EXECUTED ONLY AFTER U OPEN THE CURSOR

		TABLE ->  CURSRO+SELECT -> OPEN -> QUERY EXECUTION -> RRSULT SET --> << C-NAME


	3. FETCH ==> USED TO GET 1 ROW FROM THE RESULT SET TO THE PGM
		IF U WANT TO GET ALL ROW.. - LOOP..

		PERFROM 200-FETCH-PARA UNTIL  SQLCODE = 100

		EXEC SQL  FETCH C-NAME INTO :DCL-VAR1, :DCL-VAR2		END-EXEC.


	4. CLOSE ->  EXEC SQL CLOSE C-NAME END-EXEC


DB2 PRACTICALS

1. AFTER U LOGIN , GO BACK TO SESSION -A VISTA -> START THE DB2 DATABASE
	-DB9G START DB2

2. CREATE SOME PDS DATASET

	IBMUSER.T61.DB2
	IBMUSER.T61.DBRM
	IBMUSER.T61.DCLGEN
	IBMUSER.T61.LOAD
	IBMUSER.T61.SPUFI.OUTPUT -- CREATED BY TOOL (DONT CREATE URSELF)

3. CREATE A DB2 TABLE  --> WE USE SPUFI (SQL PROCESSING USING FILE INPUTS)

	2 FILES		1. INPUT 	-- PDS -> MEMBER -> CODE QUERY AS INPUT  ==> F3 + ENTER (EXECUTED)
			2. OUTPUT	-- PS  - CREATED BY TOOL -> RESULT WIL BE IN THIS DATASET

	FROM ISPF -> OPTION DB -> OPTION 1- SPUFI

                            SPUFI                              SSID: DB8G     
 ===>                                                                         
                                                                              
 Enter the input data set name:        (Can be sequential or partitioned)     
  1  DATA SET NAME ... ===> 'IBMUSER.T61.DB2(CLAIMTAB)'                 		<==== INPUT      
  2  VOLUME SERIAL ... ===>            (Enter if not cataloged)               
  3  DATA SET PASSWORD ===>            (Enter if password protected)          
                                                                              
 Enter the output data set name:       (Must be a sequential data set)        
  4  DATA SET NAME ... ===> 'IBMUSER.T61.SPUFI.OUT'                          		<==== OUTPUT 
                                                                              

4. CREATE THE DCLGEN COPYBOOK --> USING - DCLGEN TOOL

	FROM ISPF --> OPTION-DB > OPTION -2


                           DCLGEN                             SSID: DB8G     
===>                                                                         
                                                                             
Enter table name for which declarations are required:                        
 1  SOURCE TABLE NAME ===> IBMUSER.CLAIM_T61                                 
                                                                             
 2  TABLE OWNER ..... ===>                                                   
                                                                             
 3  AT LOCATION ..... ===>                                     (Optional)    
Enter destination data set:          (Can be sequential or partitioned)      
 4  DATA SET NAME ... ===> 'IBMUSER.T61.DCLGEN(DCLCLAIM)'                    
 5  DATA SET PASSWORD ===>           (If password protected)                 
Enter options as desired:                                                    
 6  ACTION .......... ===> ADD       (ADD new or REPLACE old declaration)    
 7  COLUMN LABEL .... ===> NO        (Enter YES for column label)            
 8  STRUCTURE NAME .. ===> DCL-CLAIM-DETAILS                   (Optional)    
 9  FIELD NAME PREFIX ===> DCL-                                (Optional)    
10  DELIMIT DBCS .... ===> NO        (Enter YES to delimit DBCS identifiers) 
11  COLUMN SUFFIX ... ===> YES       (Enter YES to append column name)       
12  INDICATOR VARS .. ===> NO        (Enter YES for indicator variables)     
13  RIGHT MARGIN .... ===> 72        (Enter 72 or 80)                        
                                                                             

5. CODE THE PGM..

	1. COBOL-DB2 PGM  --> ACCEPT  -- MOVE -- INSERT THE DATA TO TABLE
	2. COBOL-DB2-FILE PGM --> READ -> MOVE -- > INSERTED THE DATA TO TABLE
	3. COBOL-DB2-FILE-SUBPGM --> READ FILE --> SUBPGM -STRLEN01 --> MOVE --> INSERT
	4. SAME ALL AS ABOVE --> ADUTI EACH FILED AND IF CORRECT -- TABLE
							IF INVALID -> ERROR FILE

6. COMPILATION  (IBMUSER.DB2.SRC)

		1. PRE-COMPILER
		2. BIND JOB
		3. DB2 RUN JOB











2. HOW TO COBOL-DB2 PGMS
	1. CREATE A TABLE
	2. DCLGEN COPYBOOK
	3. COBOL-DB2 PGM
	4. PRE-COMPILATION***
	5. EXECUTION


COBOL-DB2 PGM -		2 CHANGES		1. INCLUDE		EXEC SQL INCLUDE SQLCA + DCLGEN.
						2. QUERY		EXEC SQL SELE/INSET.. END-EXEC

	TABE -DATA -> DCL-VAR/HOST-VAR --> PGM
	PGM -> DATA -> DCL-VAR/HOST-VAR --> TABLE		EXEC SQL  --> :DCL-VAR1,:DCL-VAR2..

PRE-COMILATION PROCESS:

		JOB J3		S1 - DSNHPC -> PRE-COMPILER
					1. REPLACE THE EXEC SQL STATEMENT WITH SUITABLE COBOL CODE...
						EXEC SQL INCLUDE -> EXPAND THE COPYBOOK INTO THE PGM
						EXEC SQL QUERY	 -> 1. EXTRACT THE QUERY AS OUTPUT ->  DBRM (DATABASE RESORUCE MODULE)
								     2. REPLACED WITH A CALL    CALL 'DSNHLI' USING SQL-VARIABLE.

					2. COMMENT ALL EXEC SQL STATEMENT
								***EXEC SQL
								***EXEC SQL

					3. OUTPUT CODE AFTER COMMENTING -> MODIFIED COBOL CODE
					4. SET A TIMESTAMP  B/W DBRM + MODIFIED CODE   (SO THEY NEED TO BE SYNC ALL WAYS WHILE EXECUTION)

				S2. - IGYCRCTL =-> MODOFIED COBOL CODE
				S3  - HEWL	- 			LOAD


COBOL+DB2 CODE ==> PRE-COMPILATION JOB (S1,S2,S3) -->   1. DBRM
							2. LOAD  --> READY FOR EXEUCTION 


BIND PROCESS --> 

	WHEN WE DO COBOL COMPILATION (IGYCRTL) -->  1. CHECK THE SYNTAX
							2. CONVERT THE CODE TO MACHINE


	SELECT CLAIM_NUMBER...  RIGHT
	SELECT CLAIM-NUMBER.... WRONG?? 

	PRE-COMPILER ONLY CHECKS THE SYNTAX OF QUERY --> SELECT CLAIM_NUMBER CUST_NAME --> ERROR   COMMA IS MISSING
	BIND PROCESS  WILL CHECK THE QUERY CORRECTION  --> SELECT CLAIM-NUMBER   	-- ERROR -- COULUMN NAME INCORRECT - SQLCODE -206

BIND PROCESS 	2 STEPS
				1. BIND PACKAGE	
						1. CHECK THE CORRECTNESS OF THE QUERY -> TABLE NAME, COLUMN , AUTHORZATION..
						2. UPDATE THE QUERY WITH REQUIRED DETAILS..
								1. SSID ??
								2. QUALIFIER(IBMUSER)	<< SCHEMA NAME	
								3. OWNER(ID WHO HAVE BIND ACCESS)
								4. ISOLATION-LEVEL - ROW LOCKING 
								5. OTHER DETAILS			==> BIND PARAMETERS..

	DURING THE BIND PROCESS -> OF CREATING A PACKAGE -> WE USE BIND PARAMETER AND UPDATE THE QUERY**

		PACKAGE --> BOUND FORM OF SQL QUERY FROM DBRM..
				UPDATED FORMAT OF THE QUERY

DB2 OBJECTS -> TABLE , VOIEW , PACKAGE  ==> NOT IN 3.4
		SYSIBM.SYSTABLES
		SYSIN.SYSPACKAGE --> NAME , DBRM , CREA/SEC , LOCK ...


	CODE A QUERY IN THIS NOTEPAD -> CAN RUN THE QUERY???    NO	== NOT CONNECTED TO DB2 SYSTEM..
	CODE A QUERY IN THE SPIFU-TOOL  -> CAN RUN THE QUERY??  YES	== CONNECTION TJHRU PLAN

IN DB2 -> CONNECTION / PATH IS THRU PLAN**

	PLAN -- IUS EXCUATBLE
		--> CONTAINS THE ACCESS PATH TO THE DB2 SSID.

BEFORE DB2 VERSION 10 ->   PGM- COBOL-DB2  -> PRC-OMPI;L -> DBRM _ LOAD ==> DBRM -> PLAN (BIND PARAMETER)
AFTER DB2 VERSION 10
	VERSION 10 ->   PGM- COBOL-DB2  -> PRC-OMPI;L -> DBRM _ LOAD ==> DBRM -> PACKAGE -->  PLAN (BIND PARAMETER)


EXECUTION OF THE COBOL+DB2 PGM

	COBOL CODE :		//STEP1  EXEC PGM=NAME-OF-CBL-NAME

	COBOL+ D2B (LOAD + PLA)	//STEP1  EXEC PGM=IKJEFT01
				//SYSTSIN  DD *
				 SSID()
				RUN PROGRAM(NAME) PLAN()
				/*
				//
	
============================================================================================================================

	PROD	TXWCT01.CLAIM_TABLE  == USE IN THE CODE..	CAN I MOVE THIS CODE TO PRODUCTION		QUEIFILER(TXWCP01)
	TEST	TXWCP01.CLAIM_TABLE  -= USE THIS IN THE CODE  -- CAN I TEST THE CODE??				QUALIFIER(TXWCT01)
			==> U SHOULD NOT USE SCHEAM-NAME IN THE QUERY**

	PROD	Z1YE001$.CLAIM_TABLE  ==> YES
	TEST	Z1YE001$.CLAIM_TABLE  ==> YES
			--> WE CAN IGNORE THE SEHCMA-NAME / OR WE CAN ALSO CODE THE SCHEMA NAME IN THE PGM QUERY

	UR APP	TXWCA01.CLAIM_TABLE
	XY APP	TXWCB01.POLICY_TABLE
					OTHER XY APP TABLE = U NEED TO CODE ALONG WITH SCEHMA NAME IN THE PGM QUERY
					UR APPLICATION (SAME SSHCEMA IN  BOTH TEST/PROD) -> U CAN OMIT THE SCEHEA NAME..





				2. BIND PLAN




































2>> DCLGEN COPYBOOK  / TABLE COPYBOOK / HOST VARIABLE ;

TABLE ->  CREATE THE COPYBOOK
			1. MANUAL
			2. TOOL  DCLGEN	== MORE USEFUL - DATA-TYPE CONVERSION
					1. IT CANNOT CREATE SUB-GROUP		EX: FNAME,LNAME,MNAME -> 03 FNAME , 03 MNAME 
											03 FULL-NAME. 05 FNAME , 05 NAME
					2. DOESNT KNOW ABT 88 LEVEL
					3.  DO ONT USE OCCURS		LOC1 ,LOC2 ,LOC3 -> MANUAL -> 03 LOC OCCURS 3 TIMES..
					4. REDEFINES

	NOTE1: DO NOT REPLACE THE DCLGEN COPYBOOK
		- IN CASE IF U ADD A NEW COL IN THE TABLE - THEN - DO NOT USE DCLGEN TOOL 
			- U NEED TO ADD NEW COL VARIBALE MANUALLY


3.>> HOW TO CODE A COBOL-DB2 PGM

	2 CHANGES WE NEED TO MAKE IN THE PGM

	ID DIVISION.	NO CHANGE
	ENVIRONMENT DIVISION.	 NO CHANGES  (IF U HAVE A FILE DEFINE HERE)
	DATA DIVISION.
	WORKING-STROAGE SECTION.

1. CHANGE:	ADD THE REQUIRED DB2 COPYBOOK

		1. SQLCA	= SQL COMMUNIATION AREA
				= PRE-CODED COPYBOOK
				= THIS CONTAINS SQL VARIBALE WHICH SYSTEM WIL USE AT THE TIME QUERY EXECUTION
			=> SQLCODE VARIABLE
				= THIS HOLD THE QUERY RESULT STATUS
				= THIS SQLCODEE VCARIABLE WE CAN TELL IF THE QUERY EXECUTED IS SUCCESS /FAILED

				SQLCODE = 000	-SUCCESFULE
					  100   - END OF THE TABLE  ? ROW NOT FOUND
					-IVE   > ERROR
					 -803 -> DUPLICATE DATA ROW INSERT
					 -206  -> COLUMN NAME IN-CORRENT
					 -805  - PLAN/PACKAGE NOT FOUND..

		2. DCLGEN OF TABLES
				WE CREATE THRU DCLGEN TOOL

		EXEC SQL  INCLUDE SQLCA END-EXEC.
		EXEC SQL INCLUDE DCL-COPYBOOK  END-EXEC.

	PROCEDURE DIVISION.

2. CHANGE	CODE THE SQL QUERY THAT

			1. SELECT  2. INSERT 3.UPDATE 4. DELETE  5. COMMIT

		EXEC SQL  QUERY ===END-EXEC.

INSERT QUERY:	 THIS QUERY IS USED TO KEEP A ROW OF DATA INTO THE TABLE..

		TOOl	:
			INSERT INTO SCHEMA.TABLENAME(COL1,COL2,COL3,...)
						VALUES('12434'.'ANIL',98902,'2021-09-09');


		PGM:	EXEC SQL
				INSERT INTO TABLENAME(COL1,COL2.COL3)
						VALUES(:DCL-VAR1, :DCL-VAR2 , :DCL-VAR3)
			END-EXEC.

	1. SCHEMA NAME IS OPTIONAL IN THE PGM QUERY
	2. HOST VARIBALE /DCL VARAIBLE - NEED TO BE PREFIX BY : COLON
	3. NO SEMICOLON


SELECT QUERY --> USED TO GET DATA FROM THE TABLE -- 

	TOOL:
		SELECT * FROM  SCHEMA.TABLENAME;		*- ALL COL , ALL ROWS
		SELECT COL1,COL2 FROM SCHEAM,TABLENAME;		COL1,COL2 ,  ALL ROWS
		SELECT COL1,COL2  FROM SCHEAM.TABLENAME
				WHERE CONDITION;		=COL1 , COL2  -> SELECTING THE ROWS ALSO
	
cobol PGM -- SINGLE ROW PROCESSING 
select QUERY - WIL RETIRVE MORE THAN 1 ROW ALWAYS

	IN COBOL-DB2
		EXCE SQL
		    SELECT  COL1,CO2..COL4
		 	INTO :DCL-VAR1,:DCL-VAR2,:DCL-VAR3
	 	    FROM TABLENAME
		    WHERE CONDITION..
		END-EXEC.


COBOL - DB2 ->   1000 LINE OF CODE
		50 LINE -> QUERY
		950 -    COBOL	==>  MOVE , IF , PERFORM




COBOL-DB2 PGM IS READY -> COMPILATION

	ONLY COBOL	-->	JOB J1		S1. IGYCRCTL 	-> CONVERT / COMPILE OF SYNTAX
						S2. HEWL	- LINK-EDIT 	
													- LOAD MODULES

	COBOL + DB2	==> 	JOB J1		S1. IGYCRCTL	-> COMPULEING THE SYNTAX  -> ERROR -> EXEC SQL..

			PRE-COMPILATION PROCESS:

				JOB J2		S1. DSNHPC	- PRE-COMPILER (IS TO REMOVE THE EXEC SQL TAG)

								1. REPLACE ALL EXEC SQL STATEMENT WITH COBOL CODE
									EXEC SQL INCLUDE ==   EXPAND THE COPYBOOK IN THE CODE
											COPY THE CODE THE PDS MEM AND KEEP IN THE PGM
									EXEC SQL QUERY  ==>	1. REPACE WITH A CALL STATEMENT
													CALL 'DSNHLI'  USING SQL-VARAIBLE
												2. EXTRACT THE SQL QUERY AS OUTPUT  = DBRM
								
								2.   COMMENT OUT THE EXEC STATMENT
									
									****EXEC SQL INCLUDE
									****EXEC SQL QUERY

								3. WIL SETUP A TIMESTAMP FOR THE DBRM & MODIFIED COBOL CODE

						S2. IGYCRCTL  --> OBJECT CODE
						S3. HEWL		--> 		LOAD

	COBOL-DB2 PGM -> PRE-COMPILE -> 	1. DBRM (EXTRACT SQL QEURY)
						2. LOAD (MACHINCE CODE)


	DBRM -> BIND PROCESS		1. PACKAGE 	2. - PLAN












CREATE THE TABLE:

	CREATE TABLE SCHEMA.TABLENAME(
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS)	IN DATABASE.TABLESPACE;



DATA -TYPE
		DB2 TYPES								COBOL DATA-TYPES

	CHAR(N)		 FIXED BYTES							PIC  X(N)
	VARCHAR(N)	 VARYING BYTES						03 GRP1.
										  49  LEN  PIC  S9(04) COMP.
		CHAR(10)  -> ANIL 		- 10 BYTES			  49  TEXT PIC  X(N).
				SUNIL		- 10 BYTES

		VARCHAR(10) ->  ANIL		- 4 BYTES
				SUNIL		- 5 BYTES


	SMALLINT	FIXED 2 BYTE BINARY						03 A	PIC S9(4) COMP.
	INTERGER	FIXED 4 BYTE BINARY						03 B	PIC S9(09) COMP.

	DECIMAL(P,Q)	P - TOTAL DIGITS , Q-DECIMAL DIGITS

		EX:  123.45	DECIMAL(5,2)						03 C PIC  S9(03)V9(02) COMP-3.


	DATE		= 	YYYY-MM-DD						X(10)
	TIME			HH.MM.SS						X(08)
	TIMESTAMP		YYYY-MM-DD-HH.MM.SS.MMMMMM				X(26)


DB2 CONSTRAINTS:

RULES THAT ARE IMPOSED ON A COLUMN OF THE TABLE TO AVOID INCORRECT/INVALID DATA INTO THE TABLES..

	TABLE:	CLAIM_TAB	

INSERT				CLAIM_NUBER 	CUSTN_NAME 	CLAIM_AMOUNT 	CLAIM_SUBMIT_DATE
R1 123,ANIL,1000,2021-09-09		123	ANIL		1000		2021-09-09
R2 123,ARUN,MISS,2021-09-09		124	ARUN		---------NULL	2021-09-09
R3					125	SUNIL		0000		2021-09-09
					123			1093		2021-09-09


		IN DB2 NULL ARE REPRESTED BY ----------
		NULL -- NOTHING  (NOT SPACE , NOT ZERO)


	1. NOT NULL		= THIS IS USED TO AVOID NULL VALUE ON A COLUMN.==> MANDARORY COL , REQUIRED COL =IF U MISS -ERROR
	2. WITH DEFAULT		= THIS IS USED TO AVOID NULL VALUE ON A COLUMN ==> OPTIONAL COL - SYSTEM WIL PLACE DEFAULT VALUE IF U MISS
	
		CLAIM_SUB_DT	CLAIM_SUB_DT(NOT NULL)		CLAIM_SUB_DT(WITH DEFAULT)	CLAIM_SUB_DT(WITH DEFAULT 2099-01-01)
2021-09-09	2021-09-09	2021-09-09			2021-09-09			2021-09-09
MISS		----------	ERROR				2021-09-28			2099-01-01

					WITH DEFAULT -. BASED ON DATA-TYPES
							NUM - SMALLINT/INTER/DECIMAL ==>00000
							AL-NUM -> CHAR/VARCHAR	===.	 SPACE.
							DATE/TIME/TIMESTAMP  -->  CURRENT DATE/TIME/TIMESTAMP

	
	IN A GIVEN ANY TABLE -> APART FROM THE DATA VCOLUMNS

		1. CREATE-TS 			WITH DEFAULT
		2. UPDATE-TS			WITH DEFAULT
		3. TOKEN/LAST-UPDATE		CONTAINS WHICH PROCES/USER/JOB UPDATED THE RECORD.



	3. UNIQUE		-- USED TO AVOID THE DUPLICATE ON A COLUMN
					-- THIS SHOULD BE NOT NULL AS WELL
				--> ON A TABLE WE CAN HAVE MANY UNIQUE CONST ON THE COLUMN

	4. PRIMARY KEY		-- USED TO AVOID THE DUPLICATE ON A COLUMN
					-- THIS SHOULD BE NOT NULL AS WELL
				-->  ON A TABLE WE CAN HAVE ONE PRIMARY KEY
				--> THIS PK COLUMN CAN BE USED FOR RELATION-SHIP  (PARENT-CHILD)


				"COL-NAME  DATA-TYPE  NOT NULL PRIMARY KEY."

>> CAN A TABLE IDENIFY THE DUPLICATES ON A COLUMN IN A TABLE??  
>> ONLY INDEX CAN FIND DUPLICATES**

		ON A GIVEN TABLE IF U HAVE ANY COLUMN , PK , UNQ  WE MUST BE DEFINING A INDEX ON THE COLUMN.

>> WE CAN HAVE A INDEX ON ANY COLUMN
		-> INDEX		== THIS CAN HAVE DUPLICATE	== USED FOR SEARCH/QUERY FASTER
		-> UNIQUE INDEX		== THIS WILL NOT ALLOW DUPLICATE  --> UNIQUE,PRIMARY KEY

	TOO MANY INDEX ON A TABLE - WIL ALSO CAUSE PERFOMANCE ISSUE



	5. FORIGEN KEY	--> THIS COL USED TO SETUP A RELATION WITH THE PARENT TABLE
			-- THE COL OF PARENT - PK 
			-- WIL BE THE SAME COL IN CHILD - FK

		 PRODUCT TABLE(PARENT)		ORDER TABLE(CHILD TABLE)
		PID,PNAME,PPRICE		OID,PID,QTY,AMOUNT,ADV-AMOUNT
		P1,LAPTOP,10			O1,P4,1000,10000,5000
		P2,KEYBOARD,20			O1,P4,10000,100000,50000
		P3,MOUSE,30			O3,P4,20000,1000000,500000	=== INSERT RULE ERROR
		P4,LAPTOP2.0,20
			
			2 NEW RULES:
				INSERT>>	1. WE CANNOT HAVE ANY CHILD ROW WITHOUT A PARENT
	 			DELETE>>	1. IN CASE TO DELETE A PARENT
							WHAT HAPPEN TO A CHILD
						
					ON DELETE CASCADE :  ALONG WITH PARENT ROW, CHILD ROW WIL BE DELETED AS WELL
					**ON DELETE RESETICT : IF WONT ALLOW THE DELETE OF PARENT ROW , IF A CHILD IS PRESENT
									--> SOL :  TO DELETE THE CHILD ROW FST AND REMOVE THE PARENT


	6. CHECK	--> IF CONDITION -- PRACTICAL'S 





COBOL + IF, PERFORM , MOVE , FILE , SUB-PROGRAM


INTRODUDCTION TO DB2:


	MAINFRAME - IS USED TO STORE & PROCESS THE DATA

		PROCESSING -> BATCH -- ONLINE  ->  COBOL + JCL
		STORING  ---> FILE  & DATABASE  -> FILE 

		DATABASE --> 		1. IDMS	-- OLDEST , FEW PROJECT
					2. IMS  --  OLD	--> MANY PROJECT
					3. DB2  --  NEW --- ALL PROJECT

	DB2 IS IBM 2ND DATABASE PRODCUT 
	IBM 1ST DATABASE -> IMS**

DB2 -- SOFTWARE - WHICH MANAGES THE DATA STORE & RETRIVE METHOD

DB2 INSTALL:	= SYSTEM PROGRAMMER

	THEY WIL INSTALL MULTIPLE COPIES FOR EACH OF THE TSO (LPAR)

LOGIN TO MAINFRAME		1. TSO		PROD		- INSTALL	-- SUB-SYSTEM ID	- SSID	- 4 CHAR -> DBP1
				2. TSO		TEST/DEV	- INSTALL
				3. TSO		QUAL		- INSTALL


	PROD - TEST - QUAL - ALL SAME TABLE == DATA WIL BE NOT SAME

	WHEN U JOIN ANY PROJECT:	
					1. TOOLS 
					2. LIB -- COBOL , JCL , PROC , CONTROL , COPYBOOK
					3. PROD , TEST = ENV
					4. DB2
						1. SSID -> PROD , TEST , QUAL

	TRAINING ==>  SSID => DB9G

DBA =DATABASE ADMIN -> MEMORY ALLOCATION FOR DB2 ..

MAINFRAME	--> Z/OS	->  DASD	-> UNIT (SYSDA,SYSALDA)		-> VOLUMNS	--> DATASET(PDS/PS) --> DATA/PGM

DBA -> ALLOCATE THE VOLUMNS OF SPACE TO DB2 SOFTWARE	=CALLED > STORAGE GROUP

STROGE-GROUP -->  DATABASE  -- TABLESPACE/INDEX-SPACE	-> SCHEMA-NAME	-> TABLE/VIEW/INDEX (DB2 OBJECTS) -->  DATA 


1. SCHEMA.TABLENAME
2. SSID.SCHEMA.TABLENAME
3. PATH ->  SSID.DATABASE.TABLESPACE.SCHEMA.TABLE.DATA

====

DB2 - SOFTWARE = USING TO STORE AND RETRIVE THE DATA..
		
	TO COMMUNICATE WITH THE DB2 SOFTWare -- WE USE SQL


SQL	==> 4 TYPE STATEMENTS

		1. DDL ==> DATA DEFINATION LANG
			
			CREATE
			ALTER
			DROP
				1. USED TO DEFINE THE STURTURE OF THE OBJECT
				2. ADMIN ACCESS (WE DONT HAVE ACCESS TO CRETAE ANY TABLE IN THE PRJECT)

			IN CASE I NEED TO CREATE A DB2 TABLE FOR MY REQUEST OF USER>

				1. PREPARE THE EXCEL 0 COL , TYPE , RULES 
				2. RAISE A REQUEST TO DB2 DBA TEAM
				3. APPROVAL  
				4. DBA WIL CREATE A TABLE - TEST SYSTEM
				5. U CAN DO UR TESTING - DONE - IMPLEMENTING THE CHANGES
				
				6. ANOTHER REQUEST FOR PROD TABLE
				7. DBA - APPROVAL -- TEST -> PROD -- ACCESS AS REQUIRED


		2. DML --> DATA MANIPULATION LANG

			SELECT		-- RETRIVE THE DATA	***		
			INSERT		== ADD THE ROW
			UPDATE		== CHANGE
			DELETE		== REMOVE

		3. TCL  - TRANSACTION CONTROL LANG
			
			COMMIT		-- SAVE THE CHANGES
			ROLLBACK	== REVERT/UNDO THE CHANGES

			ANY QUERY PROCESS 1. PGM 2. JCL 3. TOOL
	
					IF SUCCESSUFL --> AUTO-COMMIT
					WHEN FAIL   	-> AUTO -ROLLBACK


		4. DCL -- DATA CONTROL LANG
			
			GRANT	== PROVIDE THE ACCESS
			REVOKE 	-- REMOVE THE ACCESS

			ADMIN = WORK

IF AM DEVELOPER/SUPORT 

		CREATE  -- INSERT - SELECT - UPDATE - DELETE -- COMMIT













