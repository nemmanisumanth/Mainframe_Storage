1. INTRODUCTION TO DB2 / SQL
2. HOW TO COBOL-DB2 PGMS
	1. CREATE A TABLE
	2. DCLGEN COPYBOOK
	3. COBOL-DB2 PGM
	4. PRE-COMPILATION***
	5. EXECUTION
3. COBOL-DB2 PROGRAM
	1. INSERT
	2. SELECT  + CURSOR  - 305
	3. UPDATE
4. LOAD & UNLOAD
5. SQLCODE ERROR CODE
6. SQL SELECT QUERY + VIEW _ JOIN - SUB QUERY
=======================================================10-12 SESSION
2. HOW TO COBOL-DB2 PGMS
	1. CREATE A TABLE
	2. DCLGEN COPYBOOK
	3. COBOL-DB2 PGM
	4. PRE-COMPILATION***
	5. EXECUTION


COBOL-DB2 PGM -		2 CHANGES		1. INCLUDE		EXEC SQL INCLUDE SQLCA + DCLGEN.
						2. QUERY		EXEC SQL SELE/INSET.. END-EXEC

	TABE -DATA -> DCL-VAR/HOST-VAR --> PGM
	PGM -> DATA -> DCL-VAR/HOST-VAR --> TABLE		EXEC SQL  --> :DCL-VAR1,:DCL-VAR2..

PRE-COMILATION PROCESS:

		JOB J3		S1 - DSNHPC -> PRE-COMPILER
					1. REPLACE THE EXEC SQL STATEMENT WITH SUITABLE COBOL CODE...
						EXEC SQL INCLUDE -> EXPAND THE COPYBOOK INTO THE PGM
						EXEC SQL QUERY	 -> 1. EXTRACT THE QUERY AS OUTPUT ->  DBRM (DATABASE RESORUCE MODULE)
								     2. REPLACED WITH A CALL    CALL 'DSNHLI' USING SQL-VARIABLE.

					2. COMMENT ALL EXEC SQL STATEMENT
								***EXEC SQL
								***EXEC SQL

					3. OUTPUT CODE AFTER COMMENTING -> MODIFIED COBOL CODE
					4. SET A TIMESTAMP  B/W DBRM + MODIFIED CODE   (SO THEY NEED TO BE SYNC ALL WAYS WHILE EXECUTION)

				S2. - IGYCRCTL =-> MODOFIED COBOL CODE
				S3  - HEWL	- 			LOAD


COBOL+DB2 CODE ==> PRE-COMPILATION JOB (S1,S2,S3) -->   1. DBRM
							2. LOAD  --> READY FOR EXEUCTION 


BIND PROCESS --> 

	WHEN WE DO COBOL COMPILATION (IGYCRTL) -->  1. CHECK THE SYNTAX
							2. CONVERT THE CODE TO MACHINE


	SELECT CLAIM_NUMBER...  RIGHT
	SELECT CLAIM-NUMBER.... WRONG?? 

	PRE-COMPILER ONLY CHECKS THE SYNTAX OF QUERY --> SELECT CLAIM_NUMBER CUST_NAME --> ERROR   COMMA IS MISSING
	BIND PROCESS  WILL CHECK THE QUERY CORRECTION  --> SELECT CLAIM-NUMBER   	-- ERROR -- COULUMN NAME INCORRECT - SQLCODE -206

BIND PROCESS 	2 STEPS
				1. BIND PACKAGE	
						1. CHECK THE CORRECTNESS OF THE QUERY -> TABLE NAME, COLUMN , AUTHORZATION..
						2. UPDATE THE QUERY WITH REQUIRED DETAILS..
								1. SSID ??
								2. QUALIFIER(IBMUSER)	<< SCHEMA NAME	
								3. OWNER(ID WHO HAVE BIND ACCESS)
								4. ISOLATION-LEVEL - ROW LOCKING 
								5. OTHER DETAILS			==> BIND PARAMETERS..

	DURING THE BIND PROCESS -> OF CREATING A PACKAGE -> WE USE BIND PARAMETER AND UPDATE THE QUERY**

		PACKAGE --> BOUND FORM OF SQL QUERY FROM DBRM..
				UPDATED FORMAT OF THE QUERY

DB2 OBJECTS -> TABLE , VOIEW , PACKAGE  ==> NOT IN 3.4
		SYSIBM.SYSTABLES
		SYSIN.SYSPACKAGE --> NAME , DBRM , CREA/SEC , LOCK ...


	CODE A QUERY IN THIS NOTEPAD -> CAN RUN THE QUERY???    NO	== NOT CONNECTED TO DB2 SYSTEM..
	CODE A QUERY IN THE SPIFU-TOOL  -> CAN RUN THE QUERY??  YES	== CONNECTION TJHRU PLAN

IN DB2 -> CONNECTION / PATH IS THRU PLAN**

	PLAN -- IUS EXCUATBLE
		--> CONTAINS THE ACCESS PATH TO THE DB2 SSID.

BEFORE DB2 VERSION 10 ->   PGM- COBOL-DB2  -> PRC-OMPI;L -> DBRM _ LOAD ==> DBRM -> PLAN (BIND PARAMETER)
AFTER DB2 VERSION 10
	VERSION 10 ->   PGM- COBOL-DB2  -> PRC-OMPI;L -> DBRM _ LOAD ==> DBRM -> PACKAGE -->  PLAN (BIND PARAMETER)


EXECUTION OF THE COBOL+DB2 PGM

	COBOL CODE :		//STEP1  EXEC PGM=NAME-OF-CBL-NAME

	COBOL+ D2B (LOAD + PLA)	//STEP1  EXEC PGM=IKJEFT01
				//SYSTSIN  DD *
				 SSID()
				RUN PROGRAM(NAME) PLAN()
				/*
				//
	
============================================================================================================================

	PROD	TXWCT01.CLAIM_TABLE  == USE IN THE CODE..	CAN I MOVE THIS CODE TO PRODUCTION		QUEIFILER(TXWCP01)
	TEST	TXWCP01.CLAIM_TABLE  -= USE THIS IN THE CODE  -- CAN I TEST THE CODE??				QUALIFIER(TXWCT01)
			==> U SHOULD NOT USE SCHEAM-NAME IN THE QUERY**

	PROD	Z1YE001$.CLAIM_TABLE  ==> YES
	TEST	Z1YE001$.CLAIM_TABLE  ==> YES
			--> WE CAN IGNORE THE SEHCMA-NAME / OR WE CAN ALSO CODE THE SCHEMA NAME IN THE PGM QUERY

	UR APP	TXWCA01.CLAIM_TABLE
	XY APP	TXWCB01.POLICY_TABLE
					OTHER XY APP TABLE = U NEED TO CODE ALONG WITH SCEHMA NAME IN THE PGM QUERY
					UR APPLICATION (SAME SSHCEMA IN  BOTH TEST/PROD) -> U CAN OMIT THE SCEHEA NAME..





				2. BIND PLAN




































2>> DCLGEN COPYBOOK  / TABLE COPYBOOK / HOST VARIABLE ;

TABLE ->  CREATE THE COPYBOOK
			1. MANUAL
			2. TOOL  DCLGEN	== MORE USEFUL - DATA-TYPE CONVERSION
					1. IT CANNOT CREATE SUB-GROUP		EX: FNAME,LNAME,MNAME -> 03 FNAME , 03 MNAME 
											03 FULL-NAME. 05 FNAME , 05 NAME
					2. DOESNT KNOW ABT 88 LEVEL
					3.  DO ONT USE OCCURS		LOC1 ,LOC2 ,LOC3 -> MANUAL -> 03 LOC OCCURS 3 TIMES..
					4. REDEFINES

	NOTE1: DO NOT REPLACE THE DCLGEN COPYBOOK
		- IN CASE IF U ADD A NEW COL IN THE TABLE - THEN - DO NOT USE DCLGEN TOOL 
			- U NEED TO ADD NEW COL VARIBALE MANUALLY


3.>> HOW TO CODE A COBOL-DB2 PGM

	2 CHANGES WE NEED TO MAKE IN THE PGM

	ID DIVISION.	NO CHANGE
	ENVIRONMENT DIVISION.	 NO CHANGES  (IF U HAVE A FILE DEFINE HERE)
	DATA DIVISION.
	WORKING-STROAGE SECTION.

1. CHANGE:	ADD THE REQUIRED DB2 COPYBOOK

		1. SQLCA	= SQL COMMUNIATION AREA
				= PRE-CODED COPYBOOK
				= THIS CONTAINS SQL VARIBALE WHICH SYSTEM WIL USE AT THE TIME QUERY EXECUTION
			=> SQLCODE VARIABLE
				= THIS HOLD THE QUERY RESULT STATUS
				= THIS SQLCODEE VCARIABLE WE CAN TELL IF THE QUERY EXECUTED IS SUCCESS /FAILED

				SQLCODE = 000	-SUCCESFULE
					  100   - END OF THE TABLE  ? ROW NOT FOUND
					-IVE   > ERROR
					 -803 -> DUPLICATE DATA ROW INSERT
					 -206  -> COLUMN NAME IN-CORRENT
					 -805  - PLAN/PACKAGE NOT FOUND..

		2. DCLGEN OF TABLES
				WE CREATE THRU DCLGEN TOOL

		EXEC SQL  INCLUDE SQLCA END-EXEC.
		EXEC SQL INCLUDE DCL-COPYBOOK  END-EXEC.

	PROCEDURE DIVISION.

2. CHANGE	CODE THE SQL QUERY THAT

			1. SELECT  2. INSERT 3.UPDATE 4. DELETE  5. COMMIT

		EXEC SQL  QUERY ===END-EXEC.

INSERT QUERY:	 THIS QUERY IS USED TO KEEP A ROW OF DATA INTO THE TABLE..

		TOOl	:
			INSERT INTO SCHEMA.TABLENAME(COL1,COL2,COL3,...)
						VALUES('12434'.'ANIL',98902,'2021-09-09');


		PGM:	EXEC SQL
				INSERT INTO TABLENAME(COL1,COL2.COL3)
						VALUES(:DCL-VAR1, :DCL-VAR2 , :DCL-VAR3)
			END-EXEC.

	1. SCHEMA NAME IS OPTIONAL IN THE PGM QUERY
	2. HOST VARIBALE /DCL VARAIBLE - NEED TO BE PREFIX BY : COLON
	3. NO SEMICOLON


SELECT QUERY --> USED TO GET DATA FROM THE TABLE -- 

	TOOL:
		SELECT * FROM  SCHEMA.TABLENAME;		*- ALL COL , ALL ROWS
		SELECT COL1,COL2 FROM SCHEAM,TABLENAME;		COL1,COL2 ,  ALL ROWS
		SELECT COL1,COL2  FROM SCHEAM.TABLENAME
				WHERE CONDITION;		=COL1 , COL2  -> SELECTING THE ROWS ALSO
	
cobol PGM -- SINGLE ROW PROCESSING 
select QUERY - WIL RETIRVE MORE THAN 1 ROW ALWAYS

	IN COBOL-DB2
		EXCE SQL
		    SELECT  COL1,CO2..COL4
		 	INTO :DCL-VAR1,:DCL-VAR2,:DCL-VAR3
	 	    FROM TABLENAME
		    WHERE CONDITION..
		END-EXEC.


COBOL - DB2 ->   1000 LINE OF CODE
		50 LINE -> QUERY
		950 -    COBOL	==>  MOVE , IF , PERFORM




COBOL-DB2 PGM IS READY -> COMPILATION

	ONLY COBOL	-->	JOB J1		S1. IGYCRCTL 	-> CONVERT / COMPILE OF SYNTAX
						S2. HEWL	- LINK-EDIT 	
													- LOAD MODULES

	COBOL + DB2	==> 	JOB J1		S1. IGYCRCTL	-> COMPULEING THE SYNTAX  -> ERROR -> EXEC SQL..

			PRE-COMPILATION PROCESS:

				JOB J2		S1. DSNHPC	- PRE-COMPILER (IS TO REMOVE THE EXEC SQL TAG)

								1. REPLACE ALL EXEC SQL STATEMENT WITH COBOL CODE
									EXEC SQL INCLUDE ==   EXPAND THE COPYBOOK IN THE CODE
											COPY THE CODE THE PDS MEM AND KEEP IN THE PGM
									EXEC SQL QUERY  ==>	1. REPACE WITH A CALL STATEMENT
													CALL 'DSNHLI'  USING SQL-VARAIBLE
												2. EXTRACT THE SQL QUERY AS OUTPUT  = DBRM
								
								2.   COMMENT OUT THE EXEC STATMENT
									
									****EXEC SQL INCLUDE
									****EXEC SQL QUERY

								3. WIL SETUP A TIMESTAMP FOR THE DBRM & MODIFIED COBOL CODE

						S2. IGYCRCTL  --> OBJECT CODE
						S3. HEWL		--> 		LOAD

	COBOL-DB2 PGM -> PRE-COMPILE -> 	1. DBRM (EXTRACT SQL QEURY)
						2. LOAD (MACHINCE CODE)


	DBRM -> BIND PROCESS		1. PACKAGE 	2. - PLAN












CREATE THE TABLE:

	CREATE TABLE SCHEMA.TABLENAME(
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS,
	COL-NAME	DATA-TYPE	CONSTREAINTS)	IN DATABASE.TABLESPACE;



DATA -TYPE
		DB2 TYPES								COBOL DATA-TYPES

	CHAR(N)		 FIXED BYTES							PIC  X(N)
	VARCHAR(N)	 VARYING BYTES						03 GRP1.
										  49  LEN  PIC  S9(04) COMP.
		CHAR(10)  -> ANIL 		- 10 BYTES			  49  TEXT PIC  X(N).
				SUNIL		- 10 BYTES

		VARCHAR(10) ->  ANIL		- 4 BYTES
				SUNIL		- 5 BYTES


	SMALLINT	FIXED 2 BYTE BINARY						03 A	PIC S9(4) COMP.
	INTERGER	FIXED 4 BYTE BINARY						03 B	PIC S9(09) COMP.

	DECIMAL(P,Q)	P - TOTAL DIGITS , Q-DECIMAL DIGITS

		EX:  123.45	DECIMAL(5,2)						03 C PIC  S9(03)V9(02) COMP-3.


	DATE		= 	YYYY-MM-DD						X(10)
	TIME			HH.MM.SS						X(08)
	TIMESTAMP		YYYY-MM-DD-HH.MM.SS.MMMMMM				X(26)


DB2 CONSTRAINTS:

RULES THAT ARE IMPOSED ON A COLUMN OF THE TABLE TO AVOID INCORRECT/INVALID DATA INTO THE TABLES..

	TABLE:	CLAIM_TAB	

INSERT				CLAIM_NUBER 	CUSTN_NAME 	CLAIM_AMOUNT 	CLAIM_SUBMIT_DATE
R1 123,ANIL,1000,2021-09-09		123	ANIL		1000		2021-09-09
R2 123,ARUN,MISS,2021-09-09		124	ARUN		---------NULL	2021-09-09
R3					125	SUNIL		0000		2021-09-09
					123			1093		2021-09-09


		IN DB2 NULL ARE REPRESTED BY ----------
		NULL -- NOTHING  (NOT SPACE , NOT ZERO)


	1. NOT NULL		= THIS IS USED TO AVOID NULL VALUE ON A COLUMN.==> MANDARORY COL , REQUIRED COL =IF U MISS -ERROR
	2. WITH DEFAULT		= THIS IS USED TO AVOID NULL VALUE ON A COLUMN ==> OPTIONAL COL - SYSTEM WIL PLACE DEFAULT VALUE IF U MISS
	
		CLAIM_SUB_DT	CLAIM_SUB_DT(NOT NULL)		CLAIM_SUB_DT(WITH DEFAULT)	CLAIM_SUB_DT(WITH DEFAULT 2099-01-01)
2021-09-09	2021-09-09	2021-09-09			2021-09-09			2021-09-09
MISS		----------	ERROR				2021-09-28			2099-01-01

					WITH DEFAULT -. BASED ON DATA-TYPES
							NUM - SMALLINT/INTER/DECIMAL ==>00000
							AL-NUM -> CHAR/VARCHAR	===.	 SPACE.
							DATE/TIME/TIMESTAMP  -->  CURRENT DATE/TIME/TIMESTAMP

	
	IN A GIVEN ANY TABLE -> APART FROM THE DATA VCOLUMNS

		1. CREATE-TS 			WITH DEFAULT
		2. UPDATE-TS			WITH DEFAULT
		3. TOKEN/LAST-UPDATE		CONTAINS WHICH PROCES/USER/JOB UPDATED THE RECORD.



	3. UNIQUE		-- USED TO AVOID THE DUPLICATE ON A COLUMN
					-- THIS SHOULD BE NOT NULL AS WELL
				--> ON A TABLE WE CAN HAVE MANY UNIQUE CONST ON THE COLUMN

	4. PRIMARY KEY		-- USED TO AVOID THE DUPLICATE ON A COLUMN
					-- THIS SHOULD BE NOT NULL AS WELL
				-->  ON A TABLE WE CAN HAVE ONE PRIMARY KEY
				--> THIS PK COLUMN CAN BE USED FOR RELATION-SHIP  (PARENT-CHILD)


				"COL-NAME  DATA-TYPE  NOT NULL PRIMARY KEY."

>> CAN A TABLE IDENIFY THE DUPLICATES ON A COLUMN IN A TABLE??  
>> ONLY INDEX CAN FIND DUPLICATES**

		ON A GIVEN TABLE IF U HAVE ANY COLUMN , PK , UNQ  WE MUST BE DEFINING A INDEX ON THE COLUMN.

>> WE CAN HAVE A INDEX ON ANY COLUMN
		-> INDEX		== THIS CAN HAVE DUPLICATE	== USED FOR SEARCH/QUERY FASTER
		-> UNIQUE INDEX		== THIS WILL NOT ALLOW DUPLICATE  --> UNIQUE,PRIMARY KEY

	TOO MANY INDEX ON A TABLE - WIL ALSO CAUSE PERFOMANCE ISSUE



	5. FORIGEN KEY	--> THIS COL USED TO SETUP A RELATION WITH THE PARENT TABLE
			-- THE COL OF PARENT - PK 
			-- WIL BE THE SAME COL IN CHILD - FK

		 PRODUCT TABLE(PARENT)		ORDER TABLE(CHILD TABLE)
		PID,PNAME,PPRICE		OID,PID,QTY,AMOUNT,ADV-AMOUNT
		P1,LAPTOP,10			O1,P4,1000,10000,5000
		P2,KEYBOARD,20			O1,P4,10000,100000,50000
		P3,MOUSE,30			O3,P4,20000,1000000,500000	=== INSERT RULE ERROR
		P4,LAPTOP2.0,20
			
			2 NEW RULES:
				INSERT>>	1. WE CANNOT HAVE ANY CHILD ROW WITHOUT A PARENT
	 			DELETE>>	1. IN CASE TO DELETE A PARENT
							WHAT HAPPEN TO A CHILD
						
					ON DELETE CASCADE :  ALONG WITH PARENT ROW, CHILD ROW WIL BE DELETED AS WELL
					**ON DELETE RESETICT : IF WONT ALLOW THE DELETE OF PARENT ROW , IF A CHILD IS PRESENT
									--> SOL :  TO DELETE THE CHILD ROW FST AND REMOVE THE PARENT


	6. CHECK	--> IF CONDITION -- PRACTICAL'S 





COBOL + IF, PERFORM , MOVE , FILE , SUB-PROGRAM


INTRODUDCTION TO DB2:


	MAINFRAME - IS USED TO STORE & PROCESS THE DATA

		PROCESSING -> BATCH -- ONLINE  ->  COBOL + JCL
		STORING  ---> FILE  & DATABASE  -> FILE 

		DATABASE --> 		1. IDMS	-- OLDEST , FEW PROJECT
					2. IMS  --  OLD	--> MANY PROJECT
					3. DB2  --  NEW --- ALL PROJECT

	DB2 IS IBM 2ND DATABASE PRODCUT 
	IBM 1ST DATABASE -> IMS**

DB2 -- SOFTWARE - WHICH MANAGES THE DATA STORE & RETRIVE METHOD

DB2 INSTALL:	= SYSTEM PROGRAMMER

	THEY WIL INSTALL MULTIPLE COPIES FOR EACH OF THE TSO (LPAR)

LOGIN TO MAINFRAME		1. TSO		PROD		- INSTALL	-- SUB-SYSTEM ID	- SSID	- 4 CHAR -> DBP1
				2. TSO		TEST/DEV	- INSTALL
				3. TSO		QUAL		- INSTALL


	PROD - TEST - QUAL - ALL SAME TABLE == DATA WIL BE NOT SAME

	WHEN U JOIN ANY PROJECT:	
					1. TOOLS 
					2. LIB -- COBOL , JCL , PROC , CONTROL , COPYBOOK
					3. PROD , TEST = ENV
					4. DB2
						1. SSID -> PROD , TEST , QUAL

	TRAINING ==>  SSID => DB9G

DBA =DATABASE ADMIN -> MEMORY ALLOCATION FOR DB2 ..

MAINFRAME	--> Z/OS	->  DASD	-> UNIT (SYSDA,SYSALDA)		-> VOLUMNS	--> DATASET(PDS/PS) --> DATA/PGM

DBA -> ALLOCATE THE VOLUMNS OF SPACE TO DB2 SOFTWARE	=CALLED > STORAGE GROUP

STROGE-GROUP -->  DATABASE  -- TABLESPACE/INDEX-SPACE	-> SCHEMA-NAME	-> TABLE/VIEW/INDEX (DB2 OBJECTS) -->  DATA 


1. SCHEMA.TABLENAME
2. SSID.SCHEMA.TABLENAME
3. PATH ->  SSID.DATABASE.TABLESPACE.SCHEMA.TABLE.DATA

====

DB2 - SOFTWARE = USING TO STORE AND RETRIVE THE DATA..
		
	TO COMMUNICATE WITH THE DB2 SOFTWare -- WE USE SQL


SQL	==> 4 TYPE STATEMENTS

		1. DDL ==> DATA DEFINATION LANG
			
			CREATE
			ALTER
			DROP
				1. USED TO DEFINE THE STURTURE OF THE OBJECT
				2. ADMIN ACCESS (WE DONT HAVE ACCESS TO CRETAE ANY TABLE IN THE PRJECT)

			IN CASE I NEED TO CREATE A DB2 TABLE FOR MY REQUEST OF USER>

				1. PREPARE THE EXCEL 0 COL , TYPE , RULES 
				2. RAISE A REQUEST TO DB2 DBA TEAM
				3. APPROVAL  
				4. DBA WIL CREATE A TABLE - TEST SYSTEM
				5. U CAN DO UR TESTING - DONE - IMPLEMENTING THE CHANGES
				
				6. ANOTHER REQUEST FOR PROD TABLE
				7. DBA - APPROVAL -- TEST -> PROD -- ACCESS AS REQUIRED


		2. DML --> DATA MANIPULATION LANG

			SELECT		-- RETRIVE THE DATA	***		
			INSERT		== ADD THE ROW
			UPDATE		== CHANGE
			DELETE		== REMOVE

		3. TCL  - TRANSACTION CONTROL LANG
			
			COMMIT		-- SAVE THE CHANGES
			ROLLBACK	== REVERT/UNDO THE CHANGES

			ANY QUERY PROCESS 1. PGM 2. JCL 3. TOOL
	
					IF SUCCESSUFL --> AUTO-COMMIT
					WHEN FAIL   	-> AUTO -ROLLBACK


		4. DCL -- DATA CONTROL LANG
			
			GRANT	== PROVIDE THE ACCESS
			REVOKE 	-- REMOVE THE ACCESS

			ADMIN = WORK

IF AM DEVELOPER/SUPORT 

		CREATE  -- INSERT - SELECT - UPDATE - DELETE -- COMMIT













